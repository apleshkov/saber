//
//  XcodeProjectCommand.swift
//  Saber
//
//  Created by andrey.pleshkov on 02/07/2018.
//

#if os(OSX)

import Foundation
import Saber
import Commandant
import Result

struct XcodeProjectCommand: CommandProtocol {
    
    let verb = "xcodeproj"
    let function = "Generate containers from Xcode project"
    
    private let defaultConfig: SaberConfiguration
    
    init(config: SaberConfiguration) {
        self.defaultConfig = config
    }
    
    struct Options: OptionsProtocol {
        
        let url: URL
        
        let targetNames: Set<String>
        
        let outDir: URL
        
        let config: SaberConfiguration?
        
        let logLevel: String
        
        static func create(workDir: String)
            -> (_ path: String)
            -> (_ rawTargets: String)
            -> (_ outPath: String)
            -> (_ rawConfig: String)
            -> (_ logLevel: String)
            -> Options {
                let baseURL: URL? = workDir.count > 0
                    ? URL(fileURLWithPath: workDir, isDirectory: true)
                    : nil
                return { (path) in                    
                    let url = URL(fileURLWithPath: path).saber_relative(to: baseURL)
                    return { (rawTargets) in
                        let array = rawTargets
                            .split(separator: ",")
                            .map { $0.trimmingCharacters(in: .whitespaces) }
                        let targetNames = Set(array)
                        return { (outPath) in
                            let outDir = URL(fileURLWithPath: outPath).saber_relative(to: baseURL)
                            return { (rawConfig) in
                                let config: SaberConfiguration? = try? ConfigDecoder(raw: rawConfig).decode()
                                return { (logLevel) in
                                    return self.init(
                                        url: url,
                                        targetNames: targetNames,
                                        outDir: outDir,
                                        config: config,
                                        logLevel: logLevel
                                    )
                                }
                            }
                        }
                    }
                }
        }
        
        static func evaluate(_ m: CommandMode) -> Result<Options, CommandantError<Throwable>> {
            return create
                <*> m <| Option(key: "workDir", defaultValue: "", usage: "Working directory (optional)")
                <*> m <| Option(key: "path", defaultValue: "", usage: "Path to *.xcodeproj (is relative to --workDir if any)")
                <*> m <| Option(key: "targets", defaultValue: "", usage: "Comma-separated list of project target names")
                <*> m <| Option(key: "out", defaultValue: "", usage: "Output directory (is relative to --workDir if any)")
                <*> m <| Option(key: "config", defaultValue: "", usage: "Path to *.yml or YAML text (optional)")
                <*> m <| Option(key: "log", defaultValue: "info", usage: "Could be 'info' (by default) or 'debug' (optional)")
        }
    }
    
    func run(_ options: Options) -> Result<(), Throwable> {
        do {
            Logger = ConsoleLogger(level: try LogLevel.make(from: options.logLevel))
            guard options.targetNames.count > 0 else {
                throw Throwable.message("No targets found")
            }
            let config = options.config ?? defaultConfig
            Logger?.info("Xcode Project: \(options.url.path)...")
            let project = try SaberXProject(path: options.url.path, targetNames: options.targetNames)
            let factory = ParsedDataFactory()
            try project.targets.forEach { (target) in
                Logger?.info("Target '\(target.name)'...")
                try target.filePaths.forEach { (path) in
                    if path.hasSuffix(FileRenderer.fileSuffix) {
                        Logger?.info("Ignoring '\(path)': generated by Saber")
                        return
                    }
                    guard path.hasSuffix(".swift") else {
                        Logger?.info("Ignoring '\(path)': not a swift file")
                        return
                    }
                    let parser = try FileParser(path: path, config: config, moduleName: target.name)
                    try parser.parse(to: factory)
                }
            }
            try FileRenderer.render(
                params: FileRenderer.Params(
                    version: saberVersion,
                    parsedDataFactory: factory,
                    outDir: options.outDir,
                    config: config
                )
            )
            return .success(())
        } catch {
            return .failure(.wrapped(error))
        }
    }
}

#endif
